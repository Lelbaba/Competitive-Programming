\subsection{LIS DP Optimization}
The classical LIS DP is an $O(n^2)$ DP for an array $a$ where the recursive statement is 
\begin{equation}
DP(i) =  max(1 + DP(j) : j < i \ and  \ a_j\leq a_i) 
\end{equation}

This problem can be generalized as such, given some condition of compatibility in a sequence with the immediately previous element, find the longest compatible subsequence.

As long as checking the compatibility is $O(1)$ the standard solution is $O(n^2)$. This can be optimized using a segment tree.

We can store the values of $DP_i$ in a segment tree and as we iterate over the sequence, we can update them such that all the values (indices of segment tree) that will be compatible with the current element $i$ will get updated with $DP_i$

If the values are large we can map them to smaller values. 

\subsubsection{Problems:}
\begin{itemize}
	\item \href{https://codeforces.com/contest/340/problem/D}{Bubble Sort Graph}
	\item \href{https://codeforces.com/contest/1557/problem/D}{Ezzat and Grid}
\end{itemize}
